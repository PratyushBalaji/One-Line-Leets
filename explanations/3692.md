# Solution 3692 - Majority Frequency Characters

## Solution : 

```python
def majorityFrequencyGroup(self, s):
    return (lambda x: (lambda y:"".join(max(sorted([(i,y[i]) for i in y.keys()],reverse=True),key=lambda x:len(x[1]))[1])) ({i[0]:[j[1] for j in x if j[0]==i[0]] for i in x})) ([(s.count(i),i) for i in set(list(s))])
```

## Explanation : 

This code is extremely complex and involves using lambda-stacking to simulate imperative variables. Let's build the solution from the ground up to get a better feel for it.

First, lets plan how to tackle this problem.
1. We need to map every letter to its frequency in `s`
2. We need to group together letters with the same frequency
3. We need to find the maximum group : 
    - First we check for the largest group(s)
    - Tiebreakers are resolved by checking for the highest frequency
4. Somehow do it all in one line

So let's build our first list. We can iterate through `s` and store each letter with its frequency in a tuple, and put all of them in a list. Iterating through `s` will be inefficient as we are bound to have multiple instances of the same letter. So lets split `s` into a list of characters, then only iterate through unique elements using `set()`.

```python
freqList = []
for i in set(list(s)): # iterate through unique elements
    freqList.append((s.count(i),i)) # append the (frequency,letter) tuple to freqList
``` 

This can be made into a list comprehension like so : `freqList = [(s.count(i),i) for i in set(list(s))]`

Now that we have this, let's group together letters with the same frequency. I decided to do this using a dictionary, where the key is the frequency and the value is the list of letters with that frequency.

```python
freqDict = {}
for i in freqList:
    entry = freqDict.get(i[0],[]) # .get() is so we don't get an error trying to access a key with no value
    entry.append(i[1])
    freqDict[i[0]] = entry
```

Unfortunately, making this into a dictionary comprehension is going to be a little tricky. So lets instead think of this step as a dictionary where for any tuple entry `i` in the `freqList`, `i[0]` (the frequency) corresponds to a list of all `j[1]`s (the letter) in the `freqList` where `i[0]` is equal to `j[0]`. In other words, the dictionary's keys will be the frequency, and for any key we pick, the value will be a list of all the letters in `freqList` where their frequency is the same as the key.

So we will need two loops : One loop in `i`, where we iterate through everything in `freqList` in order to get the keys for the dictionary, and one loop in `j`, where for each frequency, we iterate through everything in `freqList` to find other letters with the same frequency. 

We can write this like so : `freqDict = {i[0]:[j[1] for j in freqList if j[0]==i[0]] for i in freqList}`.

This next step is optional, but will help with performance. With the current `freqDict`, we end up doing the same computation multiple times. This is because everytime we encouncter a new `i` in `freqList`, we overwrite what `freqDict[i[0]]` is, which means we recompute the dictionary entry for each frequency as many times as there are letters with that frequency, and get the **exact same list back each time**! We can avoid this using another list / set that contains only the frequencies, and iterate through that instead.

So we would then have the frequencies like so :

`frequencies = set([k[0] for k in freqList])` (using `set()` so we only have unique elements)

And replace the outer loop through `freqList` with a loop through `frequencies` instead :

`freqDict = {i[0]:[j[1] for j in freqList if j[0]==i[0]] for i in frequencies}`

This optimisation does increase memory usage by the cost of one list, but also improves runtime. It is a useful optimisation if the average size of a frequency group is larger than the number of frequency groups

Now that we have completed step two, we must finally identify the maximum group using this dictionary. We can use sorting to our advantage and first order the elements by decreasing frequency count. We sort by this condition first because in Python, if two elements in a list have the same value, `max()` returns the one with the lower index. Therefore by sorting by frequency, we don't have to include the tiebreaker logic in our comparison function. Since every letter with the same frequency is already in a group, we can guarantee that no two entries in the list will have the same frequency, thus in decreasing order, we can ensure the right entry is chosen as the maximum.

We can create a new list of tuples using our dictionary, each containing a frequency and its frequency group, then sort them in reverse order. Its important that the frequency comes first because our intention is to sort by frequency for now. Note that this list is not the same as our `freqList`, because that contained tuples with a frequency and letter, while these tuples contain a frequency and list of letters.

So we now have `sortedList = sorted([(i,freqDict[i]) for i in freqDict.keys()],reverse=True)`

Lastly, we need to find the largest group in here. We must now use a function that measures the length of the list inside the tuple as the key to find the maximum.

Therefore we finally have : `majorityGroup = max(sortedList, key=lambda entry:len(entry[1]))`. The function ensures to take the length of the list (second element of the tuple), and not the length of the tuple itself.

However, this isn't in the format we want, we need to do some final cleanup on this tuple to return the correct result in the right format. First, we want the list, not the tuple, so we can take `majorityGroup[1]` to get the list, then form the characters into a string using `"".join(majorityGroup[1])`.

Thus we can end the program by saying `return "".join(majorityGroup[1])` and our code is finished!

So we've gotten to functional code, and you might think that simply replacing each variable with its definition would be enough to bring us to one line, but unfortunately, it isn't. In `sortedList`, we use `freqDict` twice, and in `freqDict`, we use `freqList` twice (one in `frequencies`). Unless we want to replace both instances with their definitions, thereby computing the dictionary twice and the list 4 times, we need to come up with a better way to store variables. Enter : Lambda Stacking

## Lambda Stacking

Lambdas are unnamed functions intended for immediate use. They can be passed into another function (like we did with `max()`), or applied immediately to an argument. The latter is what we are more interested in.

Just like regular functions, lambdas have a scope for their argument variables. Anything inside the body of the lambda can use these variables as many times as they want. So to solve our problem, we replace as many definitions as we can without repeats, and then wrap the whole body in a lambda that takes a variable argument, immediately calling the lambda with an argument that is the definition of the variable we used.

Consider this smaller example : `lambda x: x**2 + x`. 

We want to compute `x` squared plus `x`. We've used `x` multiple times in the body, but never defined it anywhere. When we want to call this lambda, we can simply pass it an argument like so : `(lambda x: x**2 + x) (3+2)`. And it will calculate `3+2` first, then apply it to `x` everywhere in the function body. Therefore only doing the computation once, and allowing us to use the argument name in the body as if it was a regular variable.

In our example, we need to wrap two lambdas. One for `freqDict`, and one for `freqList`. The reason we need two instead of one lambda with two arguments is that `freqDict` is defined based on `freqList`, therefore it is a dependent variable. If it was independent of `freqList`, one lambda would suffice.

So wrapping `freqDict` would look like this : `(lambda freqDict: "".join(...)) ({i[0]:[j[1] for j in freqList if j[0]==i[0]] for i in freqList})`

And then this whole thing would be wrapped by `freqList` like so : `(lambda freqList: (lambda freqDict: ...) (...)) ([(s.count(i),i) for i in set(list(s))])

So finally, our code would look something like : `return (lambda freqList: (lambda freqDict: "".join(...))(...))(...)`

At last, we have solved the problem in one pythonic expression!

## Equivalent Code : 

```python
def majorityFrequencyGroup(self, s):
    freqList = []
    for i in set(list(s)):
        freqList.append((i,s.count(i)))

    freqDict = {}
    for i in freqList:
        if freqDict[i[0]]:
            freqDict[i[0]].append(i[1])
        else:
            freqDict[i[0]] = [i[1]]

    sortedList = sorted([(i,freqDict[i]) for i in freqDict.keys()],reverse=True)

    majorityGroup = max(sortedList, key=lambda entry:len(entry[1]))

    return "".join(majorityGroup[1])
```