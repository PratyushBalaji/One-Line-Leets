# Solution 3227 - Vowels Game in a String

## Solution : 

```python
def doesAliceWin(self, s):
    return next((True for i in s if i in "aeiou"),False)
    # non lazy solution : return any([i in "aeiou" for i in s])
```

## Explanation : 

This game seems complex at first, but is actually quite simple. From the example in the problem, we can see that Alice's strategy of removing vowels will always lead to her winning. 

If there are an odd number of vowels, Alice can remove the entire substring, leaving Bob with no moves. 

If there are an even number of vowels, Alice can remove a substring containing all but one of the vowels. Bob must remove 0 vowels therefore he either removes a consonant, or is left with no moves if only one vowel is remaining. If Bob removes a consonant, Alice can remove the entire rest of the string, leaving Bob with no moves.

The only time Alice will fail is if she cannot do her first move, which only happens if there are no vowels in the string to remove. While Bob can remove 0 vowels as 0 is even, Alice must remove atleast 1, therefore no vowels will lead to Bob winning.

Therefore our win condition is equivalent to checking if any vowels exist in the string.

The simple way of doing so is generating a boolean list containing whether each letter in `s` is a vowel or not, then checking for `True` values. If there is even a single `True`, Alice wins, but if they are all `False` (no vowels), then Bob wins.

We can generate the list with the list comprehension `[i in "aeiou" for i in s]` which contains the value of the boolean condition `i in "aeiou"` for each character in `s`.

We can then use Python's `any()` function to check if any of the values are `True` and return it. If there are any `True`s, `any()` returns `True`, else `False`, as required.

This is inefficient as regardless of whether we encounter one `True` and already know the result, the entire array will be computed. From the problem constraints, we know `s` can contain upto 10^5 (100000) characters, therefore this will lead to increased runtime for no reason.

We can solve this issue by instead using a generator, which lazily generates the list, only computing values as required. Modifying the list comprehension to only contain `True`s like so : `[True for i in s if i in "aeiou"]`, we can convert it to a generator expression like this : `(True for i in s if i in "aeiou")`.

We can then use `next()` to find the "next" (first) element of this expression. If the generator is empty, then no `True`s exist, and `next()` will return it's default value, which we will set to `False`.

So now we can simply return the value of `next((True for i in s if i in "aeiou"),False)`, which returns the first `True` if there are vowels, and `False` if there are no vowels and the generator is empty.

Therefore we now have an expression that lazily computes whether a vowel is in the string or not, breaks immediately as soon as it finds a vowel, or defaults to `False` if none exist in `s`. This lazy computation is much faster and halves the runtime!

## Equivalent Code : 

### Lazy Version :
```python
def scoreOfString(self, s):
    for letter in s:
        if letter in "aeiou":
            return True # breaks as soon as it finds a vowel
    return False
```

### Non-Lazy Version : 
```python
def scoreOfString(self, s):
    ret = []
    for letter in s:
        ret.append((letter in "aeiou")) # computes the whole list
    if True in ret:
        return True
    else:
        return False
```