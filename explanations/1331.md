# Solution 1331 - Rank Transform of an Array

## Solution : 

```python
def arrayRankTransform(self, arr):
    return (lambda dct: [dct[i] for i in arr])((lambda newarr: {i:1+idx for idx,i in enumerate(newarr)})(sorted(list(set(arr)))))
```

## Explanation : 

The goal is to return an array whose elements represent the rank of the corresponding elements in the original array.

The simplest way to start is by sorting all the elements of the array in ascending order. We take `set(arr)` so that we only sort unique elements and so each element has a unique rank, and we convert the set into a `list()` so it can be iterated on for the sorting. Lets call this sorted array `newarr`.

It seems simple enough to just map `newarr`'s index for any specific element to the element itself, and construct a new array that way. It would look something like this : 

```python
return map(lambda x: 1 + sorted(list(set(arr))).index(x), arr)
```

Unfortunately, while this is a "correct" solution, it will TLE since we are recomputing the sorted array and doing an $O(n)$ `index()` operation on each element in `arr`.

The recomputation can be solved through the use of lambda-stacking, so lets tackle the indexing. It makes sense to use a dictionary with the element being the key and the rank being the value. This way we only call `index()` once for each unique entry, then we have a $O(1)$ fetch operation when constructing the return array.

So essentially we have : 

```python
newarr = sorted(list(set(arr)))
dct = {}
for i in newarr:
    dct[i] = 1 + newarr.index(i) # O(n) indexing

return [dct[i] for i in arr] # O(1) fetching
```

Note we added 1 to the index because rank is 1-indexed, while arrays are 0-indexed. If we change the for loop to a dictionary comprehension and wrap `newarr` and `dct` in lambdas, we get something like this :

```python
return (lambda newarr: (lambda dct: [dct[i] for i in arr])({i:1+newarr.index(i) for i in newarr}))(sorted(list(set(arr))))
```

Unfortunately, this too TLEs. Although we have reduced the number of times we call an $O(n)$ indexing operation from the length of `arr` to the number of unique elements in `arr`, we are still calling it. In order to actually reduce the time complexity of our code, we are going to have to find a way to index in constant time.

Fortunately, our dictionary comprehension iterates through `newarr` which is in ascending order. The rank increases by 1 every element, so if we are simply able to keep track of each entry's index as we iterate through `newarr`, we essentially get constant-time indexing. We could map each element in `newarr` to its index! 

This can be done by zipping the range \[0,`len(newarr)`\) to `newarr` inside the comprehension. Like so :

```python
return (lambda newarr: (lambda dct: [dct[i] for i in arr])({i:1+idx for idx,i in zip(range(len(newarr)),newarr)}))(sorted(list(set(arr))))
```

Finally, this program passes all testcases within time and memory limits! For performance and readability reasons, we can replace `zip(range(len(newarr)),newarr)` with `enumerate(newarr)`, which is a built-in function that essentially does the same thing by keeping track of the index. The reason it is more performant is because it doesn't need to construct the `range` object, it can simply increment an internal count variable.

So we finally get our solution code : 

```python
def arrayRankTransform(self, arr):
    return (lambda dct: [dct[i] for i in arr])((lambda newarr: {i:1+idx for idx,i in enumerate(newarr)})(sorted(list(set(arr)))))
```

## Equivalent Code : 

```python
def arrayRankTransform(self, arr):
    newarr = sorted(list(set(arr)))
    dct = {}
    for idx,i in enumerate(newarr):
        dct[i] = 1 + idx

    return [dct[i] for i in arr]
```