# Solution 2022 - Convert 1D Array Into 2D Array

## Solution : 

```python
def construct2DArray(self, original, m, n):
    return [] if m*n != len(original) else [original[i*n:n+(i*n)] for i in range(m)]
```

## Alternative Solution (sans list splicing) :
```python
def construct2DArray(self, original, m, n):
    return [] if m*n != len(original) else [[original[i*n + j] for j in range(n)] for i in range(m)]
```

## Explanation : 

There are two cases for this problem : Either we can construct a 2D array, or we can't. The question states that we must use all the elements, hence so as long as the 2D array contains **exactly** as many elements as required, the construction is possible.

We can simply check if the total elements in the 2D array (`m*n`) is equal to the length of the original 1D array (`len(original)`). If the construction is not possible, we must return `[]`, and if it is, we return the 2D array.

We can identify which case we're in with the ternary expression `return [] if m*n != len(original) else ...`

Now lets focus on the construction case. There will be `m` rows in total, so we loop through the rows (`for i in range(m)`) and decide what to put in each one. Each individual row `i` will contain the `i`th group of `n` elements from `original`. So each will consist of elements from the index `i*n` to the index `n + i*n`. We can simply use list splicing based on the iteration `i` like so to achieve this : `original[i*n:n+(i*n)]`.

If for some reason you don't want to use list splicing, we can replace the splice with a for-loop that achieves the same, iterating through `n` and inserting every element from `i*n` to `n + i*n`.

Now its simply a matter of converting everything into a list-comprehension syntax and we arrive at the solution.

## Equivalent Code : 

### List splicing
```python
def construct2DArray(self, original, m, n):
    if m*n != len(original):
        return []
    else:
        ret = []
        for i in range(m):
            ret.append(original[i*n:n+(i*n)])
        return ret
```

### No list splicing
```python
def construct2DArray(self, original, m, n):
    if m*n != len(original):
        return []
    else:
        ret = []
        for i in range(m):
            temp = []
            for j in range(n):
                temp.append(original[i*n + j])
            ret.append(temp)
        return ret
```